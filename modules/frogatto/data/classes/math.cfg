//Additional functions for math.
{
tween: "def(decimal list_one, decimal list_two, decimal percent_raw) -> decimal (list_one*(percent) + list_two*(1.0-percent)) where percent = constrain(0, percent_raw, 1)",

interpolate: "overload(
	def(decimal begin, decimal percentage, decimal end) -> int tween(end, begin, percentage),
	def(list begin, decimal percentage, list end) -> list lib.list.tween(end, begin, percentage) asserting size(begin) = size(end) | {begin:begin, end:end},
	(def([decimal] begin, decimal percentage, object|map end) -> map ({mid_x:x_, mid_y:y_, 0:x_, 1:y_} where x_ = tween(decimal <- end.mid_x, begin[0], percentage), where y_ = tween(decimal <- end.mid_y, begin[1], percentage)) asserting end.mid_x != null, end.mid_y != null, size(begin)=2 | {begin:begin, end:end}),
	(def(object|map begin, decimal percentage, [decimal] end) -> map ({mid_x:x_, mid_y:y_, 0:x_, 1:y_} where x_ = tween(end[0], decimal <- begin.mid_x, percentage), where y_ = tween(end[1], decimal <- begin.mid_y, percentage)) asserting begin.mid_x != null, begin.mid_y != null, size(end)=2 | {begin:begin, end:end}),
	(def(object|map begin, decimal percentage, object|map end) -> map {mid_x:tween(decimal <- end.mid_x, decimal <- begin.mid_x, percentage), mid_y:tween(decimal <- end.mid_y, decimal <- begin.mid_y, percentage)} asserting begin.mid_x != null, end.mid_x != null, begin.mid_y != null, end.mid_y != null)
)",

floor: "def(decimal val) -> int integer(val)",
ceil: "def(decimal val) -> int if(val <= floor(val), integer(val), floor(val)+1)",
constrain: "def(decimal min, decimal var, decimal max) -> decimal if(min > max, (min+max)/2, if(min > var, min, if(max < var, max, var)))",

round: "def(decimal num) -> int if(num <= 0,
	if(num <= (integer(num) - 0.5), (integer(num) - 1), integer(num)),
	if(num >= (integer(num) + 0.5), (integer(num) + 1), integer(num))
)",

}