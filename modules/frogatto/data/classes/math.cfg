//Additional functions for math.
{
interpolate: "overload(
	//BEGIN 3 ARITY
	def(decimal begin, decimal percentage, decimal end) -> int tween(end, begin, percentage),
	def(list begin, decimal percentage, list end) -> list tween(end, begin, percentage) asserting size(begin) = size(end) | {begin:begin, end:end},
	(def([decimal] begin, decimal percentage, object|map end) -> map ({mid_x:x_, mid_y:y_, 0:x_, 1:y_} where x_ = tween(decimal <- end.mid_x, begin[0], percentage), where y_ = tween(decimal <- end.mid_y, begin[1], percentage)) asserting end.mid_x != null, end.mid_y != null, size(begin)=2 | {begin:begin, end:end}),
	(def(object|map begin, decimal percentage, [decimal] end) -> map ({mid_x:x_, mid_y:y_, 0:x_, 1:y_} where x_ = tween(end[0], decimal <- begin.mid_x, percentage), where y_ = tween(end[1], decimal <- begin.mid_y, percentage)) asserting begin.mid_x != null, begin.mid_y != null, size(end)=2 | {begin:begin, end:end}),
	(def(object|map begin, decimal percentage, object|map end) -> map {mid_x:tween(decimal <- end.mid_x, decimal <- begin.mid_x, percentage), mid_y:tween(decimal <- end.mid_y, decimal <- begin.mid_y, percentage)} asserting begin.mid_x != null, end.mid_x != null, begin.mid_y != null, end.mid_y != null),
	
	//BEGIN 2 ARITY
	def({decimal -> decimal} targets, decimal step) -> int (tween(targets[second_key], targets[first_key], (step-first_key)/total_range) where total_range = second_key - first_key where first_key=decimal(min(keys(targets))), second_key=decimal(max(keys(targets)))) asserting size(targets)=2
	
) where tween = overload(
	def(decimal list_one, decimal list_two, decimal percent_raw) -> decimal (list_one*(percent) + list_two*(1.0-percent)) where percent = constrain(0, percent_raw, 1),
	def(list list_one, list list_two, decimal percent_raw) -> list map(range(size(list_one)), 'index', list_one[index]*(percent) + list_two[index]*(1.0-percent)) where percent = lib.math.constrain(0, percent_raw, 1)
)",


floor: "def(decimal val) -> int integer(val)",
ceil: "def(decimal val) -> int if(val <= floor(val), integer(val), floor(val)+1)",
constrain: "def(decimal min, decimal var, decimal max) -> decimal if(min > max, (min+max)/2, if(min > var, min, if(max < var, max, var)))",

round: "def(decimal num) -> int if(num <= 0,
	if(num <= (integer(num) - 0.5), (integer(num) - 1), integer(num)),
	if(num >= (integer(num) + 0.5), (integer(num) + 1), integer(num))
)",

//Easeing functions. Takes a percent (a decimal between 0 and 1) and makes it closer to either extreme, depending on where it is.
sin_in:     "def(decimal percent) -> decimal 1-cos(percent*90)",
sin_in_out: "def(decimal percent) -> decimal if(percent < 0.5, sin_in(percent*2)/2, sin_out((percent-0.5)*2)/2+0.5)",
sin_out:    "def(decimal percent) -> decimal sin(percent*90)",

bezier_curve: "def([[decimal]] points, decimal percent_raw) 
	if(size(points)=2, 
		[points[0][0]*(1-percent) + points[1][0]*percent, points[0][1]*(1-percent) + points[1][1]*percent], 
		bezier_curve([[decimal]] <- map(range(size(points)-1), 'ind', bezier_curve([[decimal]] <- points[ind:ind+2], percent)), percent)
	) where percent = decimal(percent_raw) asserting size(points) > 1",

}