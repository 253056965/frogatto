{
id: "standard_values",

# rationale for this file:
#  Multiple basic prototypes use these values, and previously redundantly had them as literal constants.
#  Objects based on prototypes can't refer to the properties in said prototype if they redeclare them - they frequently do to put that value in a conditional, and they have to redeclare it as yet another redundant copy of this constant.

#  certain functions are truly global, but need the convenience of being properties for easy access to the referring object's scope
properties: {

#-------------------------- global values --------------------------#
	standard_thrown_damage: 400,
	kill_anything:  20000,		#a large int meant to be fatal to anything
	
	lower_difficulty: "level.player.difficulty < level.player.difficulty_challenging",
	higher_difficulty: "level.player.difficulty > level.player.difficulty_casual",

	max_recursion_depth: 1000,  #incorrect behavior is better than stack overflows, which we'd occasionally get if FFL is allowed to recurse indefinitely.  This has to manually be checked against a counter value.


#-------------------------- sound functions --------------------------#
	sound_falloff: "def(sound_name, falloff_dist, max_volume) sound(sound_name, volume) where volume = constrain(0, decimal(falloff_dist)/distance(self, level.player),max_volume)",
	
#-------------------------- cosmetic functions --------------------------#
	sinusoidal_transition: "def(period, init_theta, length_theta, addend, coefficient, obj,  quality) map(range(period), schedule(index, set(obj[quality], addend + coefficient*sin(init_theta + (decimal(length_theta)*index)/period )  )))", #pass quality as a string.  TODO: compress range bounds for given quality (not everything is 0.0~1.0 like scale)
	
	sinusoidal_scale_transition: "def(period, init_theta, length_theta, addend, coefficient) map(range(period), schedule(index, set(me.scale, addend + coefficient*sin(init_theta + (decimal(length_theta)*index)/period )  )))",  # we may in fact want to retain these for speed, though



	_find_floor_standable: "def(int u, int v, object obj) -> [int] [u, if(not floor_height = null, floor_height, v)] where floor_height = v + find(range(1000), object_can_stand(level, obj, u, v + value))",

	//TODO:  make this detect objects too
	floor_level_beneath_character: "def(int u, int v, object obj) -> [int] _find_floor_standable(u,v,obj)",
},
}