{
id: "throwable",
prototype: ["hittable"],
activation_border: 1000,
properties: {
	swallowable: "bool :: true",
	is_player_ammo: "bool :: false",
		
		#two special exceptions here besides the 'no friendly-fire' rule;  evil_harmless is a special team for thrown enemies wherein they can't hurt anyone, regardless of the target's team, but also - stuff from team 'evil' won't friendly-fire them.  They can and will be hurt by any player actions, though, and any traps/neutral damage sources.
	team_condition: "def(obj hittable collide_with, string collide_with_area) -> bool ((collide_with_area in ['body', 'armored'] and team != 'evil_harmless' and collide_with.team != team) and (not (team = 'evil' and collide_with.team = 'evil_harmless')))",
	damage_type: "string :: 'impact'",
	damage_cooldown: "int :: 20",

	carry_gravity: "int :: 0",  // carried objects can cause the player to be burdened down, or even to become lighter than normal

	goes_through_enemy_shots: "bool :: true",
	thrown_type: "string :: me.type",
	set_to_animation: "def(string name) -> commands set(animation, name)",

	
	dies_on_impact: "bool :: false", //typically used for throwable_projectiles; this flags something that always dies if it hits any surface with force (not just enemies, but terrain as well)
	
#-------------------------- vars --------------------------#
	time_last_bounced: { type: "int", default: 0, persistent: false }, 
	time_spat: { type: "int|null", default: null, persistent: false }, 
	juggled: { type: "int", default: 0, persistent: false }, 
	_on_back_count: { type: "int", default: 0, persistent: false },
	cycle_thrown_anim: { type: "int", default: 0, persistent: false },

	in_change_dimensions_fail: { type: "int", default: 0, persistent: false}, 
	
	
#-------------------------- cosmetic functionality --------------------------#
	play_bounce_sound:  "commands :: [
		if(material_sound='smallmetal', sound('collide-metal'+1d10+'.wav')),
		if(material_sound='metal',      sound('collide-metal-heavy'+1d7+'.wav')),
		if(material_sound='coconut',    sound('hopper-block1.wav')), 
		if(material_sound='fruit',      sound('collide-fruit'+1d3+'.wav')),
	]",
	
	
#-------------------------- core functionality --------------------------#
	speed: "decimal :: abs(hypot(velocity_x, velocity_y))",

	handle_collision_with_hittable: "def(obj hittable collide_with, string collide_with_area) -> commands execute(me, 

			process_collision(collide_with)

			where process_collision = def(obj hittable collide_with) -> commands 
			
			if(team_condition(collide_with, collide_with_area), [
				//if it is an enemy shot, try to block it
				if(collide_with.is_a_shot and (not collide_with.goes_through_enemy_shots), [collide_with.get_hit_by(me)]),

				//go ahead and receive collision damage, unless we're hitting an enemy shot.  If we are, get hit by it unless we're flagged to go through enemy shots
				if((collide_with.is_a_shot and (not me.goes_through_enemy_shots)) or (not collide_with.is_a_shot),
					if( (sourceless_damage_cooldown < (level.cycle - time_last_hit)),
					[impact_cloud(midpoint_x,y,'large'), elastic_collision(collide_with, {multiplier: 0.5, constraint: {min: 500, max: 1500} } ), me.get_hit_sourceless('impact',standard_thrown_damage),set(time_last_hit, level.cycle)]) )
			
				]
			)
		)",
		
	general_collision_handler: "def(int x_bias, int y_bias, custom_obj|null collide_with, commands terrain_response) -> commands [
									play_bounce_sound,
									if(dies_on_impact and speed > 900, die()),
									if( speed > 1000, impact_cloud(x_bias, y_bias, 'large'), if(speed > 100, impact_cloud(x_bias, y_bias, 'small'))),
									if(collide_with is obj hittable, handle_collision_with_hittable((obj hittable <- collide_with),'body'), terrain_response),
								]",
		
#-------------------------- terrain collisions --------------------------#
	terrain_response_head: "commands :: set(velocity_y, -velocity_y/2)",
	terrain_response_side: "commands :: set(velocity_x, -velocity_x/2)",
	terrain_response_feet: "commands :: 
							[
								if(animation = 'thrown' and velocity_y + abs(velocity_x) > 600, 
									[
										set(velocity_y, -(velocity_y*3)/5 - (velocity_x*slope_standing_on)/90),
										set(velocity_x, (velocity_x*4)/5 + (velocity_y*slope_standing_on)/90)
									],
									if(animation = 'thrown', [set(_on_back_count, 0), if('on_back' in available_animations, animation('on_back'))])
								),
								set(rotate, slope_standing_on),
								set(juggled, 0),
							]
							",	
		
},


#-------------------------- gets fired by frogatto immediately after the creature is launched --------------------------#
on_spat: "[set(rotate, 0),set(time_spat,level.cycle), add(juggled, 1),set(brightness, 255)]",

#-------------------------- handle interaction --------------------------#

on_been_grabbed: "",
on_collide_damage: "die()",

#-------------------------- handle collisions during thrown animations --------------------------#
on_collide_head: "general_collision_handler(mid_x, y, arg.collide_with, terrain_response_head)",
on_collide_side: "general_collision_handler(mid_x, y2, arg.collide_with, terrain_response_side)",
on_collide_feet: "general_collision_handler(mid_x, y2, arg.collide_with, terrain_response_feet)",


#-------------------------- handle error conditions --------------------------#
on_stuck: "if(not solid(level, midpoint_x, y+self.img_h-10), add(velocity_y, -1200), add(velocity_x, 1d600-300))",

	// instead of dying if they collide with frogatto/others right away, give them a brief chance to get kicked out of the way.  The former concerns associated with instadying are still dealt with because if the player does entrap them and deliberately cause this, they still cause damage.
on_change_solid_dimensions_fail: "if(in_change_dimensions_fail > 15 or (not collide_with), die(),
	          [add(in_change_dimensions_fail, 1),
			   add(velocity_x,if(collide_with.midpoint_x > midpoint_x, -500,500))
			  ]) where collide_with = obj hittable <- arg.collide_with",
			  
on_change_animation_failure: "[die()]",
on_add_object_fail: "[if(collide_with.team != team and collide_with.get_hit_by, collide_with.get_hit_by(me)), die()] where collide_with = obj hittable <- arg.collide_with",

}
