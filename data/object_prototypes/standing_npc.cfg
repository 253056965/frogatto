{
/*Implementor requires "stand" animation.
Properties: stand - The character starts standing in one place.
*/
id: "standing_npc",
prototype: ["standard_values"],
zorder: "@include data/zorder.cfg:npcs",
is_strict: true,

collide_dimensions: ["~npc"],
solid_dimensions: ["~npc"],


editor_info: {
	category: "NPCs",
},

properties: {
#--------------------------	 editor items --------------------------#
	start_mode: { type: "string", default: "stand", persistent: false, set: "set(_data, value) asserting _data = null | 'Attempted to set a property we want to be immutable'" },
	default_speech_text: { type: "string", default: "", editor_info: { type: "string", value: "" } },
	turning_behaviour: { type: "string", default: "face_player", editor_info: { type: "enum", enum_values: ["face_player","random","never"] } },


#-------------------------- cosmetic settings --------------------------#
	shadow_size: "string|null :: 'medium_small'",


#-------------------------- core functionality --------------------------#

	start_standing: "if(animation not in ['turn'] or time_in_animation >= animation_obj.total_animation_time,
							 do_stand_or_turn_behavior
					)",
	do_stand_or_turn_behavior: "switch(turning_behaviour,
									'face_player', turn_towards_player,
									'random', if(not 1d2-1 and should_turn, turn_around, animation('stand')),
									'never', animation('stand')
								)",
	
	
	do_pause: "[animation('stand'), set(_paused,true)]",
	do_resume: "[fire_event('resume'), set(_paused,false)]",

	should_turn: "bool :: level.cycle - _last_turned > 10",
	turn_around: "commands :: [if('turn' in available_animations, animation('turn')), set(facing, -facing), set(_last_turned, level.cycle)]",
	turn_towards_player: "commands :: if(not is_facing_towards_player and should_turn, turn_around, animation('stand'))",

		//a formula that can be used to draw the character's attention to an object, and make them do whatever in response to it.
	consider_object: {type: "string", default: "null" },

	do_regular_behavior: "commands :: start_standing",
	core_anims: "[string] :: ['stand','turn']",
	
	
#-------------------------- conversation functionality --------------------------#
	record_having_conversation__section: "def(int section) -> commands
											level.player.store_event('had_section_'+section+'_of_conversation_with_'+me.label+'_on_level_'+level.id, 1)",
	had_conversation_with_me_already__section: "def(int section) -> bool
											if(level.player.get_stored_event('had_section_'+section+'_of_conversation_with_'+me.label+'_on_level_'+level.id) = 1, true, false)",

	standard_conversation_distance: "int :: 100",

//	preferred_player_walk_direction
	
	is_this_direction_okay:  "def(int direction) -> bool
									level.player.is_there_flat_ground_ahead_of_us(standard_conversation_distance)
									
							",
	
	

#-------------------------- storage --------------------------#
	_paused: { type: "bool", default: false},	
	_last_turned: { type: "int", default: -100, persistent: false },
	_last_interacted: { type: "int", default: -100, persistent: false },
},


on_create: "[if(start_mode, animation(start_mode), start_standing),fire_event('enter_level')]",

on_enter_level: "if(shadow_size != null,
					if(preexisting_shadow = null, spawn('shadow_'+shadow_size,mid_x,mid_y,{parent: me})
						)   where preexisting_shadow = find(level.chars, value.spawned_by = me and value is obj shadow))",

on_being_removed: "map(filter(spawned_children, value is obj shadow), remove_object(value))",


on_end_anim: "if(not animation in core_anims, animation(animation),   if(_paused, start_standing,do_regular_behavior))",
			/*if we're doing some special animation, like the butler-kitty, we're expected to self-handle termination*/
	

on_interact: "[
		set(level.zoom, 2), 
		do_pause,
		set(level.player.control_lock, ['ctrl_left']), 
	
			//TODO:  this line does not work.  Repro case:  press the left arrow key a single time, then press up to interact;  the second instance of ctrl_left from the control_lock induces running.
		set(level.player.is_running, false) asserting level.player is obj frogatto_playable,
		set(_last_interacted, level.cycle),
		schedule(1, fire_event('check_distance')),
	]",


	/*
		Repeatedly check each frame to see if the player is far enough away;  if the player isn't and too much time goes by, we're clearly ramming into a wall or something, so fire the conversation anyways as a safeguard.
	*/
on_check_distance: "if(lib.math.length(me, level.player) > standard_conversation_distance or (level.cycle - _last_interacted > 60),
						fire_event('have_distance'),
						schedule(1, fire_event('check_distance'))
					)",

on_have_distance: "[
		set(level.player.control_lock, ['ctrl_right']),
		do_stand_or_turn_behavior,  //do it immediately rather than possibly having a long delay before the next end-of-standing-anim trigger (or failing to do it ever because the character never gets a free moment to turn) 
		schedule(2, fire_event('start_talking')),
	]",

on_start_talking: "[
		set(level.player.control_lock, null), 
		fire_event('talk'), 
		set(level.zoom, 1),
		do_resume,
	]",

on_talk: "if(default_speech_text, speech_dialog(null, [default_speech_text]))",
}
