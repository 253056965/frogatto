{
/*Implementor requires "fly", "turn", "turn_fly" animations.
Commands:	
			begin_flying - takes off and hovers in place
			cease_flying - lands, and enters a standing mode
*/
id: "flying_npc",
prototype: ["standing_npc"],
always_active: true,
zorder: "@include data/zorder.cfg:npcs",
friction: 1000,
traction: 1000,
traction_in_air: 1000,

editor_info: {
	category: "NPCs",
},

properties: {
#-------------------------- editor items --------------------------#
	start_mode: { type: "string", default: "stand", editor_info: { type: "enum", enum_values: ["stand","fly"] } },

#-------------------------- vars --------------------------#
	_last_turned: { type: "int", default: -100, persistent: false },	
	_target: { type: "{x:int, y:int}|null", default: null, persistent: false },					//If we are flying to a target, this is it.
	_target_callback: { type: "commands", default: null, persistent: false },		//The commands to run, when we reach the target. (Will be fired in addition to reach_target.)
	_current_special_flight_anim: { type: "string", default: '', persistent: false },	


#-------------------------- behavior --------------------------#
	begin_flying: "[
		set(start_mode,'fly'),
		set(_target, null)]",
		
	

		
	do_regular_behavior: "if(start_mode = 'stand', start_standing, start_flying)",
	
	start_flying: "if(should_turn, turn_around,
						if(_current_special_flight_anim != '', animation(_current_special_flight_anim), animation('fly')) )",
	
	should_turn: "if(level.cycle - _last_turned > 10, TODO)",
							
	
	
	turn_around: "[if(is_standing, animation('turn'), animation('turn_fly')), set(facing, -facing), set(_last_turned, level.cycle)]",
	
	
	flight_animations: "[string] :: ['fly', 'turn_fly']", //a list of flying animations - inheritors may supply more than this
	
	check_for_special_fly_anim: "if(animation in flight_animations and animation not in ['fly', 'turn_fly'], set(_current_special_flight_anim, animation), set(_current_special_flight_anim, ''))",
	
#-------------------------- target-seeking --------------------------#
	target_acquisition_bounds: "decimal :: 50",

	is_at_target: "bool :: (_target != null and dist_to_target < target_acquisition_bounds) and (speed < 3)",

	
	fly_to: "def({x:int, y:int} target, commands callback=null) -> commands execute(me, [
		set(_target, target),
		set(_target_callback, callback),
		set(start_mode, 'fly')
		])",

	dist_to_target: "decimal :: if(_target != null, lib.math.length( [_target.x,_target.y], me), 0)",

	flight_speed: "decimal :: 12 * min( dist_to_target/500, 1.0 )",
	flight_vel: "{x:decimal, y:decimal} :: if(_target != null,
					{
						x: cos(angle) * flight_speed,
						y: sin(angle) * flight_speed
					} where angle = lib.math.angle(me,[_target.x, _target.y]),
					{x:0,y:0})",

	process_fly: "if(_target != null, if(not is_at_target, 
						[add(velocity_x, flight_vel.x), add(velocity_y, flight_vel.y)],
						fire_event(me, 'reach_target')
					))"

},
	

on_create: "do_regular_behavior",
on_end_anim: "if(not animation in ['stand','turn','fly','turn_fly'], animation(animation),   if(_paused, start_standing,do_regular_behavior))",
			/*if we're doing some special animation, like the butler-kitty, we're expected to self-handle termination*/
					
on_resume: "do_regular_behavior",

on_process: "[if(animation in flight_animations, 
				[process_fly, check_for_special_fly_anim, if(should_turn, turn_around, if(self.is_at_target, fire_event(self,'reach_target') ))]
			)]",


//note - it's REALLY important that target_callback be last - if this gets fired during a dialogue, the other commands after target_callback don't get executed until the dialogue is finished (which essentially breaks target-seeking entirely)	
on_reach_target: "[[set(start_mode, 'stand'),start_standing], set(_target,null)
, _target_callback]",

}
