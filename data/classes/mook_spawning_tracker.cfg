{

#-------------------------- spawning criterion --------------------------#
	max_objects: { type: "int", dynamic_initialization: true },
	spawnee_type: { type: "string", default: "" },

#-------------------------- culling criterion --------------------------#
	_x_bound: { type: "int|null", default: null },
	_x2_bound: { type: "int|null", default: null },
	_y_bound: { type: "int|null", default: null },
	_y2_bound: { type: "int|null", default: null },

	is_alive_and_attached_to_level: "def(custom_obj _obj) -> bool (_obj.hitpoints > 0 or _obj in the_level.chars)",

	is_within_x_bounds: "def(custom_obj _obj) -> bool if(not (_x_bound = null or _x2_bound = null) , (_obj.mid_x > _x_bound and _obj.mid_x < _x2_bound), true)",
	is_within_y_bounds: "def(custom_obj _obj) -> bool if(not (_y_bound = null or _y2_bound = null) , (_obj.mid_y > _y_bound and _obj.mid_y < _y2_bound), true)",
	

#-------------------------- storage --------------------------#
	current_mooks: { type: "[custom_obj]", default: [] },
	this_obj: { type: "custom_obj", dynamic_initialization: true },
	the_level: { type: "level", dynamic_initialization: true },
	
#-------------------------- processing --------------------------#
		//the client using this must actually do the work of attaching the mook to the level, since that's the behavior that differs between different kinds of objects
	should_create_a_new_mook: "(size(current_mooks) < max_objects)",
	
//	possibly_allocate_new_mook: "custom_obj|null :: if(should_create_a_new_mook, this_obj.object(spawnee_type, 1,1,1), null) ",
//	allocate_new_mook: "custom_obj :: this_obj.object(spawnee_type, 1,1,1)",
	
	cull_dead_mooks: "commands :: set(current_mooks, filter(current_mooks, is_within_x_bounds(value) and is_within_y_bounds(value) and is_alive_and_attached_to_level(value)))",
	track_new_child: "def(custom_obj new_child) -> commands add(current_mooks, [new_child])",
	
	
}