{
//TODO: These should be changed to return {x:_, y:_}, but stuff uses them atm.
toPoints: "def([object|map|[decimal]] points) map(points, toPoint(value))",
toPoint: "overload(
	def(object point)    [decimal, decimal] <- [point.mid_x, point.mid_y],
	def(map point)       [decimal, decimal] <- [lib.math.default(decimal|null <- point.mid_x, decimal|null <- point.x), lib.math.default(decimal|null <- point.mid_y, decimal|null <- point.y)],
	def([decimal] point) [decimal, decimal] <- point,
)",

/*TODO code saoen3: This bit of code is commented out for now, until we decide how to properly handle the new Point types.
//Transition function, as lots of older code expects a point in the format of [x,y].
//New code should use the Point type, defined as Point2d{x:Numeric, y:Numeric}.
toListPoint: "def(Point pin) -> [decimal] [decimal] <- [pin.x, pin.y]",

toPoint2d: "overload(
	def(object pin) -> Point2d Point2d <- {x:pin.mid_x, y:pin.mid_y},
	def(map pin) -> Point2d Point2d <- {x:lib.math.default(decimal|null <- pin.mid_x, decimal|null <- pin.x), y:lib.math.default(decimal|null <- pin.mid_y, decimal|null <- pin.y)}, //We default to using mid_x/y because we pretty much always want the midpoint if we have one.
	def([Numeric] pin) -> Point2d Point2d <- {x:pin[0], y:pin[1]},
)",

toPoint3d: "overload(
	def(object pin) -> Point3d Point3d <- {x:pin.mid_x, y:pin.mid_y, z:pin.mid_z or 0},
	def(map pin) -> Point3d Point3d <- {x:lib.math.default(decimal|null <- pin.mid_x, decimal|null <- pin.x), y:lib.math.default(decimal|null <- pin.mid_y, decimal|null <- pin.y), z:lib.math.default(decimal|null <- pin.mid_z, decimal|null <- pin.z)},
	def([Numeric] pin) -> Point3d Point3d <- {x:pin[0], y:pin[1], z:pin[2]},
)",
*/

//Returns the center-point of the level.
camera: "def(object level) -> [int] [
	cam[0]+cam[2]/2-in_editor*130,
	cam[1]+cam[3]/2+in_editor*20
] asserting size(cam) = 4
  where cam = [int]<- level.camera_position,
        in_editor = int <- level.in_editor",

decimal: "overload( //This, and int, was made to patch old math that assumed you could subtract 1.0 and true to get 0.0.
	def(int     v) -> decimal decimal(v),
	def(decimal v) -> decimal v,
	def(any     v) -> decimal if(v,1.0,0.0) asserting v!=null
)",

int: "overload(
	def(int     v) -> int v,
	def(decimal v) -> int int(v),
	def(any     v) -> int if(v,1,0) asserting v!=null
)",

}