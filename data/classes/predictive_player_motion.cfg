{
	constructor: "prepump_player_history",

	_player_history: {type: "[[int]]", default: []}, //[x,y,vel_x,vel_y,cycle]
	
	pump_player_history: "commands :: set(_player_history, ([new_player_history] + _player_history)[:_number_of_frames_in_history])",
	new_player_history: "[int] <- closest_player.mid_xy+closest_player_vel+[the_level.cycle]",
	prepump_player_history: "commands :: set(_player_history, [new_player_history] * _number_of_frames_in_history)",

	closest_player_vel: "[int] <- [ vel[0] /100, vel[1] /100] where vel = closest_player.velocity_xy",
	
	prediction: "def(int number_of_frames_to_look_ahead) -> [int, int]
								[
									the_level.player.mid_x - (inv_pred[0] - the_level.player.mid_x),
									the_level.player.mid_y - (inv_pred[1] - the_level.player.mid_y)
								] where inv_pred = inverse_prediction(number_of_frames_to_look_ahead)",
	
	inverse_prediction: "def(int number_of_frames_to_look_ahead) -> [int, int] predict_from(
		map(fold(_player_history[size(_player_history)-samples:], zip([int]<-a,[int]<-b)), (int<-value)/samples)
	) asserting size(_player_history) >= samples | q(It's not possible to sample further back in history than we've actually recorded)  
	where samples = number_of_frames_to_look_ahead",
	
	_number_of_frames_in_history: { type:"int", default:30 },
	
	predict_from: "def([int] hist) -> [int, int] [
		hist[0]+(hist[2]*(this_obj.cycle-hist[4]))/100,
		hist[1]+(hist[3]*(this_obj.cycle-hist[4]))/100
	]",


	closest_player: "obj player_controlled_platformer_character <- 
		sort(the_level.players, lib.math.length(this_obj, a) < lib.math.length(this_obj, b))[0]",
		    
	the_level: { type: "level", dynamic_initialization: true },
	this_obj: { type: "custom_obj", dynamic_initialization: true }	
}

//This class creates a pool of pseudo random numbers, which allow you the same benefit of doing e.g. 1d3 to pick one out of a set of behaviors for a character in frogatto, but with the safety of a guarantee that it's evenly distributed over a certain small interval of rolls, and that you won't get long runs of the same random value.  The main call for this is that some boss fights only allow the player to attack when the boss is in a particular "mode"; if the boss potentially never rolls this mode (as would be the case for a "true" random number), then we have no real control over the difficulty level of a fight - it could easily become impossible with a bad run of numbers.

//To use this, you need to 1]create an instance of the class (because it internally needs to store the pool it picks numbers from).  2] every time you pick a number, you need to separately query what said number is, and then cull it from the pool, in that order.  These have to be done separately because of FFL's functional nature; you can't have a function that both evaluates to a number and modifies a value.


/*  example usage:
properties: {
	_player_pos_predictor: { type: "class predictive_player_motion", init: "construct('predictive_player_motion')", persistent: false }
}

on_process: "[
				_player_pos_predictor.pump_player_history(),
				set(mid_xy, _player_pos_predictor.prediction(30))
			]",
*/