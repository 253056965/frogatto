{
id: "kitty_sniper",
prototype: ["stationary_vulnerable"],
solid_area: [16,10,36,33],
is_strict: true,
always_active: true,

properties: {
	"@derive": "@include data/object_prototypes/enemies/kitty.cfg:properties",
	find_duration: 50, //Must be greater than aim_lag! Frames, 25 = 1/2 second.
	aim_lag: 15, //Sequence: Finding → locked on. Finding has the crosshairs all over the map, but it tweens into the predicted position. From here, we either lock on and commit to the shot, or keep trying predicted positions from aim_lag frames ago.
	lock_on_duration: 10,
	max_range: 1500,
	min_range: 250,
	
	aim_at: "def(PointLike target)->commands [
		if(0 < frame and frame < frames/2, set(facing, -1)), //Don't flip for straight up/down, to add in a little continuity/personality/lazyness.
		if(frames/2 < frame and frame < frames, set(facing, 1)),
		set(time_in_animation, int(lib.math.interpolate([0,8,0], frame/1.0/frames))), //We've got separate animations for straight up and down, so we animate up to and back down from the apex.
	] where frame = m.loop(m.round(m.angle(me, target)/(360/16.0)-frames/4), frames)
	  where m = lib.math
	  where frames = 16",
	  
	short: "bool <- min_range > lib.math.length(me, closest_player)",
	in_range: "bool <- lib.math.is_sorted([min_range, lib.math.length(me, closest_player), max_range])",
	far: "bool <- lib.math.length(me, closest_player) > max_range",
	
	crosshairs: { //Zylot lent me one of his from the Crosshair Dimension. Thanks, Zylot! :D
		type: "obj kitty_sniper.target",
		init: "object('kitty_sniper.target')",
	},
	
	player_history: {type: "[[int]]", default: []}, //[x,y,vel_x,vel_y,cycle] - cache. If a prediction from n frames ago grants a reasonably accurate picture of now, then continue using that prediction to shoot Frogatto!
	
	pump_player_history: "def()->commands set(player_history, 
		([closest_player.mid_xy+closest_player.velocity_xy+[level.cycle]] + player_history)[:aim_lag] )",
	
	prediction: "[int, int] <- ([ 
		hist[0]+(hist[2]*(cycle-hist[4]))/100,
		hist[1]+(hist[3]*(cycle-hist[4]))/100 ] 
		where hist = [int]<-last(player_history)) asserting size(player_history) = aim_lag",
	
	closest_player: "sort(level.players, lib.math.length(me, a) < lib.math.length(me, b))[0]",
	
	snipe_sequence_starting_cycle: {type: "int", default: 0},
	snipe_sequence_cycle: "int <- cycle-snipe_sequence_starting_cycle",
},

editor_info: {
	"@derive": "@include data/object_prototypes/enemies/kitty.cfg:editor_info",
},

/* State Machine of a Sniper:
scan ← target out of range, far (or hidden?)
scan → find (pump player_history) → seek (pump player_history) → lock_on & shoot → reload → find…
defend ← target out of range, near
Notes: Scan can go to defend. While it is unlikely that we'll skip over find, it is not impossible – for example, if the player enters via a near door.
*/

on_create: "[
	set(animation, 'snipe'),
	fire_event('scan'),
]",

on_scan: "[
	debug('scanning'),
	aim_at(closest_player),
	
	schedule(1, 
		if(in_range, 
			fire_event('start_snipe'),
			fire_event(if(short, 'defend', 'scan')),
		),
	),
]",

on_start_snipe: "[
	add_object(crosshairs),
	set(snipe_sequence_starting_cycle, cycle),
	fire_event('find'),
]",

on_find: "[
	debug('finding'),
	aim_at(closest_player),
	pump_player_history(),
	//TODO: Add find effect here. Possibly a random jitter applied to nearest_player.mid_xy fading to the predicted aim. Use cycle-snipe_sequence_starting_cycle to grab time.
	
	schedule(1, 
		if(in_range, 
			fire_event(if(snipe_sequence_cycle>find_duration, 'seek', 'find')),
			[fire_event(if(short, 'defend', 'scan')), remove_object(crosshairs)],
		),
	),
]",

on_seek: "[
	debug('seeking…'),
	aim_at(closest_player),
	pump_player_history(),
	
	set(crosshairs.mid_xy, prediction),
	
	schedule(1, 
		if(in_range, 
			fire_event('seek'),
			[fire_event(if(short, 'defend', 'scan')), remove_object(crosshairs)],
		),
	),
]",

on_defend: "[
	debug('defending'),
	
	schedule(1, 
		if(in_range, 
			fire_event('start_snipe'),
			fire_event(if(short, 'defend', 'scan')),
		),
	),
]",

animation: [
	{
		id: "attract", //Look sniper-y for the editor. The default pose, facing straight-down, is hard to recognise out of context.
		image: "enemies/kitty-sniper.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		rotate_on_slope: true,
		body_area: [23,14,23,25],
		no_remove_alpha_borders: true,
		rect: [285,1,"@eval 285+68",69],
		frames: 1,
		duration: 99999999,
	},{
		id: "snipe", //One frame for each of the drawn 180° rotations.
		image: "enemies/kitty-sniper.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		rotate_on_slope: true,
		body_area: [23,14,23,25],
		no_remove_alpha_borders: true,
		rect: [1,1,68,71],
		frames: 9,
		duration: 1, //3.3 weeks
	},
],

object_type: [{
	id: "smoke_trail",
	is_strict: true,
	zorder: "@include data/zorder.cfg:in_front_of_everything",
	
	animation: {
		id: "disperse",
		image: "enemies/kitty-sniper-bullet.png",
		rect: [1,0,10,9],
		frames: 4,
		pad: 3,
		duration: 4,
	},
},{
	id: "target",
	is_strict: true,
	zorder: "@include data/zorder.cfg:in_front_of_everything",
	
	animation: {
		id: "normal",
		image: "effects/particles.png",
		x: 23,
		y: 197,
		w: 28,
		h: 28,
	},
}],
	
}