{
id: "gazer_boss",
prototype: ["hittable"],
always_active: true,
editor_info: {
	category: "boss",
},

properties: {
#-------------------------- hittable overrides --------------------------#
	attack_damage:  "if(true, kill_anything, 0)",
	team:  			"if(true, 'evil', 'evil_harmless')",
	
	title: "~Gazer Boss~",
	description: "~When you stare into The Great Eye, it also stares into you!  And fires death beams at you, because eyes totally do that sometimes.  Honest.~",
	taste: "~AHA!~",

	
	custom_damage_table: "{
		neutral: 1.0,
		fire: 1.0,
		energy: 0.5,
		arcane: 0.25,
		acid: 0.0,
		impact: 0.0,
		impale: 1.0,
		lacerate: 1.0
	}",

#-------------------------- core behavior --------------------------#
	rotation_speed_max: "0.65",
	rotation_speed: "if(cycle - _time_started_laser < laser_deceleration_timeslice, 
						lib.math.constrain(0, rotation_speed_max*((cycle - _time_started_laser)/laser_deceleration_timeslice), rotation_speed_max),
						if(_time_started_laser + _current_laser_duration - cycle < laser_deceleration_timeslice,
							lib.math.constrain(0, rotation_speed_max*((_time_started_laser + _current_laser_duration - cycle)/ laser_deceleration_timeslice), rotation_speed_max),
							rotation_speed_max
						)
					) * _rotation_direction",


	process_behavior: "commands ::	[		
										switch(_state,
											'idle',				process_idle,
											'attack_laser',		process_laser,
											'spawn_mooks',		process_spawn_mooks
										),
										debug(cycle - _phase_started_at, ' : ', _current_phase_random_timer)
									]",
													
	pick_random_behavior: "commands :: [
											switch(_behavior_mode_prng.get_next_value,
												1, ; begin_idle,
												2, ; begin_laser,
												3, ; begin_spawn_mooks
											),
											_behavior_mode_prng.iterate_random_pool,
											; set(_phase_started_at, cycle)
										]",
	pick_specific_behavior: "def( commands new_behavior ) -> commands	[
																			; new_behavior,
																			; set(_phase_started_at, cycle)
																		]",
#-------------------------- idle mode --------------------------#
	begin_idle: "commands ::	[
									set(_state,'idle'),
									set(_current_phase_random_timer, 100+1d50)
								]",

	process_idle: "commands :: 	[
									add(rotate, sin(cycle*7) * 0.05 + sin(cycle*3) * 0.15 + sin(cycle*2.5) * 0.25),
									if(cycle - _phase_started_at = 50, trigger_single_mook_aggro),
									if(cycle - _phase_started_at = _current_phase_random_timer, pick_random_behavior)
								]",
		
#-------------------------- laser mode --------------------------#
	begin_laser: "commands :: [
									set(_current_laser_duration, lib.math.round( base_laser_duration - (laser_duration_variance/2.0) + 1d(laser_duration_variance) )),
									set(_rotation_direction, if(1d2=2, -1, 1)),
									set(_state,'attack_laser'),
									set(_time_started_laser,cycle), 
									add_object(_laser_beam),
									fire_event(_laser_beam,'create')
								]",
	stop_laser: "[
					remove_object(_laser_beam),
					fire_event(_laser_beam,'destroy'),
					pick_specific_behavior(begin_idle)
				]",
	
	process_laser: "[
						add(rotate, rotation_speed),
						if(cycle - _time_started_laser > _current_laser_duration, stop_laser),
					]",
					
	approximate_laser_arc_length: "360.0",
	base_laser_duration: "decimal :: (approximate_laser_arc_length / rotation_speed_max) * (1 + (2.0 * laser_deceleration_timeslice_ratio))",
	laser_deceleration_timeslice: "base_laser_duration * laser_deceleration_timeslice_ratio",
	laser_deceleration_timeslice_ratio: "1/6.0",
	laser_duration_variance: "base_laser_duration * 1.0/5.0",
	
	
#-------------------------- spawn mooks mode --------------------------#
	begin_spawn_mooks: "commands :: [
									set(_state,'spawn_mooks'),
									set(_current_phase_random_timer, 100+1d50)
							]",

	process_spawn_mooks: "commands :: 	[
									add(rotate, sin(cycle*7) * 0.05 + sin(cycle*3) * 0.15 + sin(cycle*2.5) * 0.25),
									if(cycle - _phase_started_at = 50, spawn_mooks),
									if(cycle - _phase_started_at = _current_phase_random_timer, pick_random_behavior)
								]",

								
	mook_pos: "lib.math.random_radial_pos({min_angle: 0, max_angle: 359, origin: {x: me.mid_x, y: me.mid_y}, min_length: 250, max_length: 350})",

	existing_mooks: "filter(level.chars, value is obj gazer_small_bare)",

	existing_mook_count: "size(existing_mooks)",

	max_mook_count: "8",

	spawn_mooks: "map(range(max_mook_count - existing_mook_count), spawn('gazer_small_bare', mid_x, mid_y, {facing: if(1d2=2,1,-1)}, [child.fly_to([{x: lib.math.round(target.x), y: lib.math.round(target.y)}])]) where target = mook_pos)",
	
	
	trigger_single_mook_aggro: "if(the_mook != null, [
									the_mook.warn_flash_sequence,
									schedule(20, set(the_mook._target_obj, level.player)),
									debug('mook aggroed')
									
								]) where the_mook = choose(existing_mooks)",


#-------------------------- vars --------------------------#
	_behavior_mode_prng:	{ type: "class pseudo_random_numbers", init: "construct('pseudo_random_numbers',{_size_of_pool:3, _pool_size_multiplier: 3})", persistent: false },


	_phase_started_at: { type: "int", init: "0", persistent: false },
	_current_phase_random_timer: { type: "int", init: "0", persistent: false },
	_current_laser_duration: { type: "int", init: "0" },
	_rotation_direction:  { type: "int", init: "1" },
	_laser_beam: { type: "obj gazer_boss.beam", init: "object('gazer_boss.beam', mid_x, mid_y, {parent: me})" },
	_time_started_laser: { type: "int", init: "0", persistent: false },
	_state: { type: "string", default: "", persistent: false },
},
		
on_create:  "begin_spawn_mooks",

on_process: "process_behavior",

animation: [
{
	"@base": true,
	image: "enemies/gazer-boss1.png",
	attack_area: "all",
	body_area: "all",
	no_remove_alpha_borders: true,
},
{
	id: "normal",
	rect: [1,1,125,125],
	frames:1,
	duration: 10,
},
],

object_type: [
	{
		id: "beam",
		always_active: true,
		serializable: false,
		zorder: 20,
		
		properties: {
			texture_offset: "0",
			beam_length: "800",
			
			draw_w: "img_w/2",
			pupil_offset: "64.0",
			width_coefficient: "img_w/pupil_offset * (decimal(0.5*img_h)/img_w)", //<- this is some black magic, here.   
			
			beam_angle: "parent.rotate - (90 - parent.rotation_speed) asserting parent is obj gazer_boss",

			offset: "{ x: decimal, y: decimal } :: { x: length * cos(beam_angle),
													 y: length * sin(beam_angle) - (beam_length - (width_coefficient) * pupil_offset)} where length = (pupil_offset + beam_length)", 

			update_attache: "[
								set(_the_attache.beam_angle, beam_angle),
								set(_the_attache.beam_distance, beam_length + pupil_offset)
							]",

			_the_attache: { type: "obj damage_beam_attache", init: "object('damage_beam_attache', mid_x, mid_y, {parent: parent, relative_x: 0, relative_y: 0})" },
		},
		
		on_create: "[add_object(_the_attache), set(_the_attache.mid_x, parent.mid_x), set(_the_attache.mid_y, parent.mid_y)] asserting parent != null",
		on_destroy: "[remove_object(_the_attache)]",
		
		on_process: "[
						update_attache,
						//debug(decimal(0.5*img_h)/img_w),
						//debug(draw_w/decimal(img_h)),
						set(relative_x, offset.x),
						set(relative_y, offset.y),
						set(rotate, parent.rotate),
						set(draw_area, [0, texture_offset, draw_w, beam_length])
		
					] asserting parent != null",
		
		on_end_anim: "animation('normal')",
		
		animation: [{
			id: "normal",
			image: "enemies/gazer-boss-beam1.png",
			rect: [0,0,72,31],
			frames: 6,
			reverse: true,
			pad: 0,
			duration: 2,
			no_remove_alpha_borders: true,
		}],

	}
],

}