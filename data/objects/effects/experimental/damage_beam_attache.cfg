{
	id: "damage_beam_attache",
	is_strict: true,
	zorder: "@include data/zorder.cfg:in_front_of_everything",
	always_active: true,
	solid_dimensions: [],

	prototype: ["hittable"],
	editor_info: {
		category: "   ",
	},

	properties: {
		taxonomy: "'neutral'",
		attack_damage: "int :: if(higher_difficulty, 2, 1)",
		team: "string :: 'evil'",
	has_mini_hp_bar: "bool :: false",

	
		beam_angle: { type: "decimal", init: "60.0" },
		beam_distance: "decimal :: 180.0",
		attack_diameter: "decimal :: 40.0",
		attack_radius: "decimal :: lib.math.round( attack_diameter / 2.0 )",
		hitbox_count: "decimal :: lib.math.ceil(beam_distance / (attack_radius / 1.0))",


		offset: "{ x: decimal, y: decimal } :: { x: length * cos(beam_angle), y: length * sin(beam_angle) } where length = (beam_distance / hitbox_count)", 

		hitbox_animation: "map :: {
								id: 'image',
								image: 'effects/particles.png',
								x: 0,
								y: 0,
								w: 20,
								h: 20,
								//attack_area: 'all',
								body_area: 'all',
								attack_area: [-attack_radius, -attack_radius, attack_radius, attack_radius, 'solid'],
							}",

		set_hitboxes: "commands :: [
								set(animation, hitbox_animation),
								map( range(1, hitbox_count),
									spawn('damage_beam_attache.hitbox_object', x,y, {facing: facing, mid_x: mid_x + (offset.x * value), mid_y: mid_y + (offset.y * value), animation: hitbox_animation}) )
							]"
	},

	on_process: "[set_hitboxes, add(beam_angle, 1)]",
	
	on_create: "set_hitboxes",

object_type: [
	{
		id: "hitbox_object",
		always_active: true,
		serializable: false,
		
		on_create: "schedule(2, die())",
		prototype: ["hittable"],
		
		properties: {
			taxonomy: "'neutral'",
			attack_damage: "int :: if(higher_difficulty, 2, 1)",
			team: "string :: 'evil'",
	has_mini_hp_bar: "bool :: false",

		
		}
	}
],

}
