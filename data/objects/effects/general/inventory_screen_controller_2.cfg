{
id: "inventory_screen_controller_2",
ignore_collide: true,
zorder: "@include data/zorder.cfg:ovelaid_gui_dialog_underlay",
use_absolute_screen_coordinates: true,
blend_mode_source: "zero",
blend_mode_dest: "dst_color",
is_strict: true,

types: {
	Vector: "Point",
},

properties: {
	//Config Options:
	pause_level: true,
	panel_separation: 600,
	max_slide_duration: 10, //tween duration between the inventory and map panels

	//Art Config Options:
	panel_dimensions: [256, 256],


	//Properties:
	inventory_gui_elements: { type: "[custom_obj]", default: [] },

	frogatto: "obj frogatto_playable <- level.player",

	panel_offset: {
		type: "function() -> Vector",
		init: "def() [0,0]",
	},

	num_panels: {type: "int", dynamic_initialization: true},
	focused_panel_num: {type: "int", default: 0},
	
	status_panel_text_display: {
		type: "obj text_controller",
		init: "object('text_controller', 0,0,1, {
			use_absolute_screen_coordinates: true,
			zorder: lib.zorder.get('ovelaid_gui_dialog_gui_element'),
			txt: ~inventory~,
			align: 'center',
		})",
	},


	//Functions:

	reposition_ui: "def() -> commands
		set(me.mid_xy, lib.standardize.to_int_point(panel_offset()))",


	slide_start_cycle: {default: 1},
	slide: "def() -> decimal lib.math.constrain(0, (cycle-slide_start_cycle)/1.0/max_slide_duration, 1)",


	//Slide the panels around on screen by setting a function that gives their location.
	//Note: "from" should always be panel_offset(). If we directly reference panel_offset in the property, when we set panel_offset to the new offset-finding function, the function will happily recurse to death because it's now calling itself. To prevent this from happening, we need to be calling the /old/ function for the panel offset, which is captured when it's passed in as a parameter.
	slide_from_to: "def(Point from, Point to) -> commands [
		set(slide_start_cycle, cycle),
		map(range(1, max_slide_duration+1), schedule(value, bind_command(reposition_ui))),
		set(panel_offset, def() -> Point
			Point <- lib.math.interpolate(from, lib.math.interpolate(lib.math.ease_out_sine(slide()), 0.1, slide()), to) ),

	]",

	//1 to slide left, -1 to slide right.
	slide_to_relative_panel: "def(int direction) -> commands [
		set(focused_panel_num, new_panel_num),
		slide_from_to(panel_offset(), [-panel_separation*new_panel_num,0])
	] where new_panel_num = lib.math.constrain(0, focused_panel_num+direction, num_panels-1)",
	
	wrapped: "def(string txt, int line_width) -> string
		switch(true,
			size(txt) <= line_width, 
				txt, 
			nl_index >= 0 and nl_index <= line_width+1, 
				txt[:nl_index+1] + wrapped(txt[nl_index+1:], line_width), 
			true, 
				txt[:break_index-1] + '\n' + wrapped(txt[break_index:], line_width) 
					where break_index = line_width - index(reverse(split(txt[:line_width], '')), ' ')
		) 
		where nl_index = index(split(txt, ''), '\n')",

	snap_to_panel: "def(panel_num) -> commands [
		set(mid_x, -panel_separation*1),
		set(focused_panel_num, 1),
		set(panel_offset, def() lib.standardize.to_int_point(mid_xy)),
	]",


	add_status_panel: "def(int index) -> commands [
		add_object(status_pane),

		set_widgets(
			status_pane,
			{
				//Frogatto image.
				type: 'image',
				image: if(frogatto.swallowed_object, 'characters/fat-frogatto-spritesheet1.png', 'characters/frogatto-spritesheet1.png'),
				area: [2,89,33,121],
				image_width: (33-2)*4,
				image_height: (121-89)*4,
				x: 370+24, y: 25+8,
			},

			if(frogatto.swallowed_object, {
				//Frogatto belly contents.
				type: 'animation',
				object: frogatto.swallowed_object.type, //frogatto.type works just as well, here.
				name: 'on_back',
				x: 435+24, y: 120+8,
			}),

			//Trophy display
			map(
				filter(
					[
						{kind: 'ant',          rect: [0,0,31,31]}, //Image rects, from trophy.cfg
						{kind: 'kitty',        rect: [32,0,63,31]},
						{kind: 'bunny',        rect: [64,0,95,31]},
						{kind: 'milgramblock', rect: [96,0,127,31]},
						{kind: 'fumper',       rect: [0,32,31,63]},
						{kind: 'bat',          rect: [32,32,63,63]},
						{kind: 'fish',         rect: [64,32,95,63]},
						{kind: 'squirrel',     rect: [96,32,127,63]}
					],
					frogatto.get_stored_event('trophy_' + value.kind + '_acquired')
				),
				{
					//Trophy icons
					type: 'image',
					image: 'props/trophies.png',
					area: value.rect,
					x: 36 + index * 58,
					y: 435,
				}
			),
		),
		
		map(filter(keys(frogatto.items_carried), value != 'tongue'), 'item_name', 
			add_object(object('${me.type}.status_pane_item_display', 0, 0, 1, {
				animation: item_name,
				count: frogatto.number_of_item(item_name),
				parent: status_pane,
				relative_x: -183+72*positions[index][0],
				relative_y: -155+72*positions[index][1],
			}))
		) where positions = [[item_x,item_y] | item_x <- range(4), item_y <- range(4)],
		
		[
			add_object(txt),
			set(txt.parent, status_pane),
			set(txt.relative_x, -80),
			set(txt.relative_y, 135),
		] where txt = status_panel_text_display,
		
		map(frogatto.ability_list, 'ability_name',
			add_object(object('${me.type}.status_pane_ability_display', 0, 0, 1, {
				animation: ability_name + if(frogatto.current_ability_name = ability_name, '_active', ''),
				parent: status_pane,
				relative_x: 150 + 16.5*(int :: [0,4,0,4,0,4][index]),
				relative_y: -32 + 17.0*(int :: [0,0,4,4,8,8][index]),
			}))),

	] where status_pane = object(
		'${me.type}.status_pane', 0,0,1, {
			relative_x: level.camera_position[2]/2 + index*panel_separation,
			relative_y: level.camera_position[3]/2,
			use_absolute_screen_coordinates: true,
			zorder: int<-lib.json.get_document_map('data/zorder.cfg').ovelaid_gui_dialog_back_panel,
			parent: me,
		}
	)",



	add_map_panel: "def(int index) -> commands [
		add_object(map_pane),

		spawn('text_controller', 0,0, {
			relative_x: 0,
			relative_y: -200,
			use_absolute_screen_coordinates: true,
			zorder: int<-lib.json.get_document_map('data/zorder.cfg').ovelaid_gui_dialog_gui_element,
			txt: level.id,
			align: 'center',
			parent: map_pane,
		}),

		spawn('minimap_controller', 0,0, {
			relative_x: 0,
			relative_y: 0,
			use_absolute_screen_coordinates: true,
			zorder: int<-lib.json.get_document_map('data/zorder.cfg').ovelaid_gui_dialog_gui_element,
			parent: map_pane,
		}),

	] where map_pane = object(
		'${me.type}.map_pane', 0,0,1, {
			relative_x: level.camera_position[2]/2 + index*panel_separation,
			relative_y: level.camera_position[3]/2,
			use_absolute_screen_coordinates: true,
			zorder: int<-lib.json.get_document_map('data/zorder.cfg').ovelaid_gui_dialog_back_panel,
			parent: me,
		}
	)",



	add_bestiary_panel: "def(int index) -> commands [
		add_object(bestiary_pane),
		add_object(bestiary_note_display),
		add_object(object(
			'widget_carousel', 0,0,1, ({
				relative_x: _rel_x,
				relative_y: _rel_y,
				use_absolute_screen_coordinates: true,
				parent: bestiary_pane,
				offset: [-369+_rel_x,231+_rel_y], //magic!
				display: map(beasts, 'beast', {
					//Panel contents
					type: 'animation',
					object: beast.type, //frogatto.type works just as well, here.
					name: switch(true,
						'walk' in beast.available_animations, 'walk',
						'fly' in beast.available_animations, 'fly',
						beast.animation),
					x: 64+index*64, y: 0, // beast.solid_rect.h or beast.img_h/2/2 to y-align on feet.
					//on_click: def()->commands debug('clicked ${beast.type}'), //this doesn't work
				}),
				on_change: def(string enemy_name) -> commands 
					bestiary_note_display.set_text(
						  obj.title+' ('+obj.taxonomy+')\n \n'
						+ wrapped(obj.description, 41)+'\n \n'
						+ if(frogatto.enemies_tasted[obj.frogourmet_tag] and obj.taste, wrapped(~Taste: ~+obj.taste, 41) + '\n', '')
					) where obj = obj hittable <- object(enemy_name),
			} where _rel_x = 0, _rel_y = -100))
		) where beasts = filter(
			map(keys(frogatto.enemies_seen), obj hittable <- object(value)), 
			value.is_enemy_character or value is obj throwable_projectile
		),

		set_widgets(
			bestiary_pane,
			
			//{
			//	//In theory, this creates a nice horizontal scrollbar. In practice, it does not.
			//	type: 'scrollbar',
			//	range: 10,
			//	position: [2,5],
			//	enabled: 1,
			//	visible: 1,
			//	step: 1,
			//	arrow_step: 1,
			//	on_scroll: def(a,b) -> commands [debug('scrolled', a, b)], //this doesn't work
			//	x: 200, y: 64,
			//	w: 20, h: 100,
			//	//rotation: 90,
			//}
		),

		//spawn('text_editor_controller', 0,0, { //this doesn't work, can't be focused
		//	//default_text: 'search',
		//	relative_x: 100,
		//	relative_y: -200,
		//	use_absolute_screen_coordinates: true,
		//	zorder: int<-lib.json.get_document_map('data/zorder.cfg').ovelaid_gui_dialog_gui_element,
		//	parent: bestiary_pane,
		//}),

		//
	] where 
		bestiary_note_display = object('text_controller', 0,0, {
			relative_x: -200,
			relative_y: 0,
			use_absolute_screen_coordinates: true,
			zorder: int<-lib.json.get_document_map('data/zorder.cfg').ovelaid_gui_dialog_gui_element,
			txt: q(),
			parent: bestiary_pane,
		})
	where
		bestiary_pane = object(
			'${me.type}.bestiary_pane', 0,0,1, {
				relative_x: level.camera_position[2]/2 + index*panel_separation,
				relative_y: level.camera_position[3]/2,
				use_absolute_screen_coordinates: true,
				zorder: int<-lib.json.get_document_map('data/zorder.cfg').ovelaid_gui_dialog_back_panel,
				parent: me,
			}
		),
	",
},

on_create: "[
	//Pause
	if(pause_level, set(level.paused, true)),
	if(pause_level, set(me.paused, false)),

	//Fade black backdrop in.
	null or set(draw_area, if(pause_level,
		[0, 0, level.camera_position[2]/2 + panel_separation + img_w, level.camera_position[3]/2 + img_h], //+img_w/h: draw_area seems to floor to a a multiple of base width/height here
		[0, 0, 0, 0]
	)),

	//Alpha doesn't work with blend_modes set.
	//map(range(steps), schedule(value, set(alpha, int(lib.math.ease_out_sine(value/1.0/steps)*128)))) where steps = 10,

	//Add gui.
	reposition_ui(), //set menu to starting position

	//Keep the input that opened the inventory screen from closing the inventory screen.
	if(not pause_level, add(frogatto.cycle, 1)),
	if(not pause_level, set(frogatto.control_lock, [])),

	[
		map(panes_to_add, ({test: any, add: function(int) -> commands} <- value).add(index)),
		set(num_panels, size(panes_to_add)),
	] where panes_to_add = filter([
			{test: true, add: add_bestiary_panel},
			{test: true, add: add_status_panel},
			{test: frogatto.get_stored_event('inventory_map_unlocked'), add: add_map_panel},
		], ({test: any, add: function(int) -> commands} <- value).test),
		
	//;slide_to_relative_panel(1),
	;snap_to_panel(1),
]",

//To auto-reload this, add spawn('inventory_screen_controller_2', 0,0,1), to frogatto's on_process.
on_type_updated: "[
	//debug('Killed inventory screen on reload. (c${level.cycle})'),
	die(),
]",

on_die: "[
	/* Doesn't work with blend_modes set.
	//Fade black backdrop out.
	map(range(steps), schedule(value, set(alpha, int(lib.math.ease_out_sine((steps-value)/1.0/steps)*128)))) where steps = 10,
	*/

	//Despawn
	map(spawned_children, [
		remove_object(value),
		fire_event(value, 'die'),
	]),

	//Unpause
	if(pause_level, set(level.paused, false)),
	if(not pause_level, set(frogatto.control_lock, null)),
]",

on_process: "[
	frogatto.track_key('i'), //close inventory
	frogatto.track_key(left),
	frogatto.track_key(right),

	if(pause_level, add(frogatto.cycle, 1)), //pump cycle to get keyboard inputs
	if(cycle > 1 and frogatto.ctrl_keyboard('i') = 1, [ //>1: Prevent open then close.
		die()
	]),

	if(frogatto.ctrl_keyboard(left)  = 1, slide_to_relative_panel(-1)), //Can't put panel_offset() in slide_from_to.
	if(frogatto.ctrl_keyboard(right) = 1, slide_to_relative_panel( 1)),
] where right = 1073741903,
         left = 1073741904 //sdl keycodes
",


//on_wheel neither supports x scroll nor fires on this object.

animation: {
	id: "normal",
	image: "tiles/black_tile_overlay.png",
	x:0, y:0, w:16, h:16,
	frames: 1,
	duration: -1,
},

object_type: [
	{
		"@base": true,
		use_absolute_screen_coordinates: true,
	},
	
	{
		id: "status_pane",
		zorder: "@include data/zorder.cfg:ovelaid_gui_dialog_back_panel",
		animation: {
			id: "normal",
			image: 'gui/pause-menu/panel-background-stone.png',
			x:0, y:0, w:276, h:264,
		}
	},{
		id: "map_pane",
		zorder: "@include data/zorder.cfg:ovelaid_gui_dialog_back_panel",
		animation: {
			id: "normal",
			image: 'gui/pause-menu/panel-background-parchment.png',
			x:0, y:0, w:290, h:264,
		}
	},{
		id: "bestiary_pane",
		zorder: "@include data/zorder.cfg:ovelaid_gui_dialog_back_panel",
		animation: {
			id: "normal",
			image: 'gui/pause-menu/panel-background.png',
			x:0, y:0, w:256, h:256,
		}
	},
	
	{
		id: "status_pane_item_display",
		zorder: "@include data/zorder.cfg:ovelaid_gui_dialog_gui_element",
		
		properties: {
			count: {type: 'int'},
		},
		
		on_create: "if(count > 1, text('\n\n\n\n\n\n\n\n\nx${count}', 'white_outline', 2, 'right'))",
		
		on_mouse_move: "parent.parent.status_panel_text_display.set_text(item_name) asserting parent.parent is obj inventory_screen_controller_2 asserting parent asserting item_name is string
			where item_name = {
				acquirable_attractor: object('buyable_acquirable_attractor'),
				greater_mana_talisman: object('buyable_greater_mana_talisman'),
				lesser_mana_talisman: object('buyable_lesser_mana_talisman'),
				tongue_extension: object('buyable_tongue_extension'),
			}[animation].short_item_name",
		
		animation: [{
			"@base": true,
			image: "props/store-items.png",
			frames: 1,
			scale: 4,
		},{
			id: "acquirable_attractor",
			rect: [1,247,17,262],
		},{
			id: "greater_mana_talisman",
			rect: [1,111,17,126],
		},{
			id: "lesser_mana_talisman",
			rect: [1,94,17,109],
		},{
			id: "tongue_extension",
			rect: [1,179,17,195],
		},],
	},
	
	{
		id: "status_pane_ability_display",
		zorder: "@include data/zorder.cfg:ovelaid_gui_dialog_gui_element",
		
		properties: {
			frogatto: "obj frogatto_playable <- level.player",
		
			displayed_ability: "{
				tongue: 'tongue',
				firebreath: 'firebreath',
				energyshot: 'energyshot',
				homingshot: 'homingshot',
				acidbreath: 'acidbreath',
				tongue_active: 'tongue',
				firebreath_active: 'firebreath',
				energyshot_active: 'energyshot',
				homingshot_active: 'homingshot',
				acidbreath_active: 'acidbreath',
			}[animation]",
		},
		
		on_mouse_move: "parent.parent.status_panel_text_display.set_text(item_name) asserting parent.parent is obj inventory_screen_controller_2 asserting parent asserting item_name is string
			where item_name = {
				tongue: if(not frogatto.swallowed_object, ~tongue~, ~spit~),
				firebreath: if(not super, ~fire breath~, ~fireball~),
				energyshot: if(not super, ~energy shot~, ~energy blast~),
				homingshot: if(not super, ~homing shot~, ~orbit shield~),
				acidbreath: if(not super, ~acid ball~,   ~acid wave~),
			}[displayed_ability] 
			where super = frogatto.stomach_contents_allow_super_attack,
		",
		
		on_click: "[
			set(frogatto.current_ability_name, displayed_ability),
			
			map(filter(level.active_chars, value.type = me.type), 'ability_display',
				fire_event(ability_display, 'deactivate_graphic')),
			fire_event(me, 'activate_graphic'),
		]",
		
		on_deactivate_graphic: "set(animation, displayed_ability)",
		on_activate_graphic: "set(animation, displayed_ability + '_active')",
		
		animation: [{
			"@base": true,
			image: "props/store-items.png",
			frames: 1,
			scale: 3,
		},{
			id: "tongue",
			rect: [121,179,137,194],
		},{
			id: "firebreath",
			rect: [121,196,137,211],
		},{
			id: "energyshot",
			rect: [121,145,137,160],
		},{
			id: "homingshot",
			rect: [121,213,137,228],
		},{
			id: "acidbreath",
			rect: [121,230,137,245],
		},{
			id: "tongue_active",
			rect: [001,179,017,194],
		},{
			id: "firebreath_active",
			rect: [001,196,017,211],
		},{
			id: "energyshot_active",
			rect: [001,145,017,160],
		},{
			id: "homingshot_active",
			rect: [001,213,017,228],
		},{
			id: "acidbreath_active",
			rect: [001,230,017,245],
		},],
	},
	
],
}