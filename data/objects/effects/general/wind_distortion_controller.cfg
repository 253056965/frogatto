{
id: "wind_distortion_controller",
hidden_in_game: true,
always_active: true,
is_strict: true,

properties: {
	_x_bound: { type: "int", editor_info: { type: "x", value: "x-100" } },
	_x2_bound: { type: "int", editor_info: { type: "x", value: "x+150" } },
	_y_bound: { type: "int", editor_info: { type: "y", value: "y-100" } },
	_y2_bound: { type: "int", editor_info: { type: "y", value: "y+150" } },

	//the zorder range the wind effect will take place on.
	begin_zorder: { type: "int", default: -1000000 },
	end_zorder: { type: "int", default: 1000 },

	//the current 'state' of the wind. Gets passed to the wind shader.
	wind_state: { type: "decimal", default: 0.0 },
	desired_wind_state: "decimal :: if(moth_boss != null, if(moth_boss.behavior = 'windgust', moth_boss.wind_gust_direction, 0.0), 0.0) where moth_boss = find(level.chars, value is obj moth_boss)",
},

editor_info: {
	category: "controllers",
},

on_create: "if(find(level.frame_buffer_shaders, value.shader_info = 'wind_distort') = null,
	add(level.frame_buffer_shaders, [{
		begin_zorder: begin_zorder,
		end_zorder: end_zorder,
		shader_info: 'wind_distort',
	}])
)
",

on_process: "[	
				//basically we're just doing a gradual transition from the current state to the target state, but we want to do this funky math to make it smoother than a linear transition (which, as in almost all other things, looks quite bad, here)
				set(wind_state, lib.math.constrain(0.0, sign(diff) * max(abs(diff/2),abs(diff)) * 0.05 + wind_state, 1.0)) where diff = (desired_wind_state - wind_state),

				[set((object<- (object<- shader.shader).uniform_commands).u_wind_state, wind_state) | shader <- level.frame_buffer_shaders, shader.shader_info = 'wind_distort', shader.begin_zorder = begin_zorder, shader.end_zorder = end_zorder]
]",
}
